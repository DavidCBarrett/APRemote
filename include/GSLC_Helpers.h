//
// Created to enable GSLC calls to be used from other files (unfortunately you cannot include the auto generated 
// <projectname>_GLSC.h file in more than one place in your project or you get multiple declaration erroers.)
// items are copied from autogenerated ApRemote_GSLC.h, and where needed, are changed to "extern"
//
// This file will need manually updating from ApRemote_GSLC.h if changes are made to the GUI.
//

#pragma once

// ------------------------------------------------
// Headers to include
// ------------------------------------------------
#include <Arduino.h>
#include "GUIslice.h"
#include "GUIslice_drv.h"
//#include "ApRemote_GSLC.h"
#define MAX_STR 100

// Include any extended elements
//<Includes !Start!>
// Include extended elements
#include "elem/XCheckbox.h"
#include "elem/XSlider.h"
#include "elem/XTextbox.h"
//<Includes !End!>

// ------------------------------------------------
// Create element storage
// ------------------------------------------------
extern gslc_tsGui                      m_gui;
extern gslc_tsDriver                   m_drv;
extern gslc_tsFont                     m_asFont[];
extern gslc_tsPage                     m_asPage[];

// ------------------------------------------------
// Program Globals
// ------------------------------------------------

// Element References for direct access
//<Extern_References !Start!>
extern gslc_tsElemRef* m_pElemBrnBaseWiFi;
extern gslc_tsElemRef* m_pElemBtnAprAuto;
extern gslc_tsElemRef* m_pElemBtnAprMinusOne;
extern gslc_tsElemRef* m_pElemBtnAprMinusTen;
extern gslc_tsElemRef* m_pElemBtnAprPlusOne;
extern gslc_tsElemRef* m_pElemBtnAprPlusTen;
extern gslc_tsElemRef* m_pElemBtnAprPortTack;
extern gslc_tsElemRef* m_pElemBtnAprStandby;
extern gslc_tsElemRef* m_pElemBtnAprStbdTack;
extern gslc_tsElemRef* m_pElemBtnAprTrack;
extern gslc_tsElemRef* m_pElemBtnAprWind;
extern gslc_tsElemRef* m_pElemBtnBaseApr;
extern gslc_tsElemRef* m_pElemBtnBaseData;
extern gslc_tsElemRef* m_pElemBtnBaseDiag;
extern gslc_tsElemRef* m_pElemBtnWifiConfigure;
extern gslc_tsElemRef* m_pElemBtnWifiReset;
extern gslc_tsElemRef* m_pElemRadioButtonAprAuto;
extern gslc_tsElemRef* m_pElemRadioButtonAprStandby;
extern gslc_tsElemRef* m_pElemRadioButtonAprTrack;
extern gslc_tsElemRef* m_pElemRadioButtonAprWind;
extern gslc_tsElemRef* m_pElemTextAprDisplay;
extern gslc_tsElemRef* m_pElemTextDataDepth;
extern gslc_tsElemRef* m_pElemTextDataHdg;
extern gslc_tsElemRef* m_pElemTextDataSog;
extern gslc_tsElemRef* m_pElemTextDataSow;
extern gslc_tsElemRef* m_pElemTextDataWDir;
extern gslc_tsElemRef* m_pElemTextDataWind;
extern gslc_tsElemRef* m_pElemTextWifiClientSSID;
extern gslc_tsElemRef* m_pElemTextWifiIp;
extern gslc_tsElemRef* m_pElemTextWifiSSID;
extern gslc_tsElemRef* m_pElemTextWifiStatus;
extern gslc_tsElemRef* m_pElemTextboxDiagLog;
extern gslc_tsElemRef* m_pElemTextboxWiFiDiag;
extern gslc_tsElemRef* m_pTextSliderBaseStatus;
extern gslc_tsElemRef* m_pTextSliderDiagLog;
extern gslc_tsElemRef* m_pTextSliderWifiDiag;
//<Extern_References !End!>


// DCB's GUI Slice Helper functions ...
/*
 A note on TextBox elements with scroll bars.
 1. need a scroll bar handler so when the user scroll the text box is redrawn to show the correct part of the character buffer.
    see CbSlidePos in main .cpp
 2. scroll bars are ineffective unless the textbox's buffer is larger than the textbox window height (in rows). 
    In GUISice Builder, text box proerties:
    a. Set the text box size (in rows) to say 100 rows), the textbox will resize & be too big for the screen,
    b. Set the text box height (in pixels) to make the textbox fit your screen design.
    Scroll bar then works.
 3. when text is added to the box (e.g. below). when the screen is full, the screen doesnt auto scroll up (so you can see 
    the last items added). This feels like a missing feature. The GUISlice XTextbox.c functions handle the buffer, adding, 
    resetting & redrawing the text box & doesnt seem to do or have options for "autoscroll". Important items seem to be:
    pxData->scrollPos, nBufPosY, nBufPosX nWndStart. Needs a question to the GSLC team....?? 
*/


////
// GSLC_TextBox_Helper 
//
class GSLC_Helpers
{
protected:
  gslc_tsGui* pGui;
  gslc_tsElemRef** ppElemRef;
public:
   GSLC_Helpers(gslc_tsGui* _pGui, gslc_tsElemRef** _ppElemRef);
   ~GSLC_Helpers() {}
};

////
// GSLC_RadioBtn_Helper 
//
class GSLC_RadioBtn_Helper : protected GSLC_Helpers
{
public:
  GSLC_RadioBtn_Helper(gslc_tsGui* _pGui, gslc_tsElemRef** _ppElemRef);

  ~GSLC_RadioBtn_Helper() {};

  void setStatus(bool Status);
 
};

class GSLC_TextBox_Helper : protected GSLC_Helpers
{
public:
  typedef enum {TxtOutPlay, TxtOutPaused} TxtOutStatusEnum;

private:
  TxtOutStatusEnum TxtOutStatus = TxtOutStatusEnum::TxtOutPlay;

public:
  GSLC_TextBox_Helper(gslc_tsGui* _pGui, gslc_tsElemRef** _ppElemRef);

  ~GSLC_TextBox_Helper() {};

  void setTextOutStatus(TxtOutStatusEnum Status) {TxtOutStatus=Status;}
  TxtOutStatusEnum getTextOutStatus() {return TxtOutStatus;}

  void clear();

  void printf(const char* format, ...);

};

////
// GSLC_Txt_Helper 
//
class GSLC_Txt_Helper : public GSLC_Helpers
{
private:
   /* data */
public:
  GSLC_Txt_Helper(gslc_tsGui* _pGui, gslc_tsElemRef** _ppElemRef);
  ~GSLC_Txt_Helper() {}

  void printf(const char* format, ...);

};